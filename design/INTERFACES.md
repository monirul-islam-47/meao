# Interface Specifications

**Status:** ACTIVE
**Version:** 1.0
**Last Updated:** 2026-01-29

This document defines all Zod schemas and TypeScript interfaces for meao. These are the contracts that plugins and components must conform to.

**Related Documents:**
- [ARCHITECTURE.md](./ARCHITECTURE.md) - System overview
- [TOOL_CAPABILITY.md](./TOOL_CAPABILITY.md) - Tool security policies
- [LABELS.md](./LABELS.md) - Content labeling
- [MEMORY.md](./MEMORY.md) - Memory operations

---

## Table of Contents

1. [Core Types](#core-types)
2. [Channel Plugin](#channel-plugin)
3. [Skill Plugin](#skill-plugin)
4. [Tool Plugin](#tool-plugin)
5. [Memory Types](#memory-types)
6. [Provider Types](#provider-types)
7. [Event Types](#event-types)
8. [Configuration](#configuration)
9. [Versioning Policy](#versioning-policy)

---

## Core Types

### ID Conventions

meao uses two types of identifiers:

| Type | Format | Used For | Examples |
|------|--------|----------|----------|
| **Internal ID** | UUID v4 | All meao-generated entities | User.id, Session.id, Message.id |
| **Platform ID** | Opaque string | IDs from external platforms | Telegram user ID, Discord message ID |

```typescript
// Internal IDs are always UUIDs (generated by meao)
// Platform IDs are opaque strings (format varies by platform)
//
// Examples:
//   Internal: "550e8400-e29b-41d4-a716-446655440000"
//   Telegram: "123456789"
//   Discord:  "1234567890123456789"
//   Slack:    "U024BE7LH"
```

### User

```typescript
import { z } from 'zod'

// ID Types
// ─────────────────────────────────────────────────────────────
// INTERNAL IDs (generated by meao):  UUID format
// PLATFORM IDs (from channels):      Opaque strings, format varies
// ─────────────────────────────────────────────────────────────

// Internal UUID (generated by meao)
export const InternalIdSchema = z.string().uuid()

// Platform ID (from external channels - format varies by platform)
export const PlatformIdSchema = z.string().min(1)

// Coercible date (handles both Date objects and ISO strings from JSON)
export const CoercibleDateSchema = z.coerce.date()

// User identity (abstract, maps from channel identities)
export const UserSchema = z.object({
  id: InternalIdSchema,              // Internal UUID

  // Role in the system (owner is identified by role, not special ID)
  role: z.enum(['owner', 'user', 'guest']),

  // Display info
  displayName: z.string().max(100),

  // Channel identities that map to this user
  identities: z.array(z.object({
    channelId: z.string(),           // 'telegram', 'discord', 'cli'
    platformUserId: PlatformIdSchema, // Platform-specific ID (opaque string)
    username: z.string().optional(), // Platform username if available
  })),

  // Timestamps (coercible for JSON compatibility)
  createdAt: CoercibleDateSchema,
  lastSeenAt: CoercibleDateSchema,

  // Settings
  preferences: z.record(z.unknown()).optional(),
})

export type User = z.infer<typeof UserSchema>

// Helper to check if user is owner
export function isOwner(user: User): boolean {
  return user.role === 'owner'
}
```

### Session

```typescript
// Conversation session
export const SessionSchema = z.object({
  id: InternalIdSchema,              // Internal UUID
  userId: InternalIdSchema,          // References User.id

  // Which channel this session is on
  channelId: z.string(),
  conversationId: PlatformIdSchema,  // Channel-specific conversation ID

  // State
  status: z.enum(['active', 'paused', 'ended']),

  // Active skill (if any)
  activeSkillId: z.string().optional(),

  // Timestamps (coercible for JSON compatibility)
  createdAt: CoercibleDateSchema,
  updatedAt: CoercibleDateSchema,
  expiresAt: CoercibleDateSchema.optional(),

  // Metadata
  metadata: z.record(z.unknown()).optional(),
})

export type Session = z.infer<typeof SessionSchema>
```

### Message

```typescript
// Content types
export const TextContentSchema = z.object({
  type: z.literal('text'),
  text: z.string(),
})

// Media content must have either url OR base64 (not neither, not both required)
const mediaDataRefinement = <T extends { url?: string; base64?: string }>(
  data: T,
  ctx: z.RefinementCtx
) => {
  if (!data.url && !data.base64) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'Either url or base64 must be provided',
    })
  }
}

export const ImageContentSchema = z.object({
  type: z.literal('image'),
  url: z.string().url().optional(),
  base64: z.string().optional(),
  mimeType: z.string(),
  alt: z.string().optional(),
}).superRefine(mediaDataRefinement)

export const FileContentSchema = z.object({
  type: z.literal('file'),
  url: z.string().url().optional(),
  base64: z.string().optional(),
  filename: z.string(),
  mimeType: z.string(),
  size: z.number().int().positive(),
}).superRefine(mediaDataRefinement)

export const AudioContentSchema = z.object({
  type: z.literal('audio'),
  url: z.string().url().optional(),
  base64: z.string().optional(),
  mimeType: z.string(),
  duration: z.number().optional(),  // seconds
}).superRefine(mediaDataRefinement)

export const MessageContentSchema = z.discriminatedUnion('type', [
  TextContentSchema,
  ImageContentSchema,
  FileContentSchema,
  AudioContentSchema,
])

export type MessageContent = z.infer<typeof MessageContentSchema>

// Incoming message (from channel)
export const IncomingMessageSchema = z.object({
  id: PlatformIdSchema,              // Platform's message ID

  // Source
  channelId: z.string(),
  platformMessageId: PlatformIdSchema, // Channel's message ID (same as id)
  conversationId: PlatformIdSchema,    // Channel's conversation ID

  // Sender
  senderId: PlatformIdSchema,        // Platform user ID
  senderName: z.string().optional(),

  // Content (can have multiple parts)
  content: z.array(MessageContentSchema).min(1),

  // Reply context
  replyTo: PlatformIdSchema.optional(), // Platform message ID being replied to

  // Timestamps (coercible for JSON compatibility)
  timestamp: CoercibleDateSchema,

  // Raw platform data (for debugging)
  raw: z.unknown().optional(),
})

export type IncomingMessage = z.infer<typeof IncomingMessageSchema>

// Outgoing message (to channel)
export const OutgoingMessageSchema = z.object({
  // Content
  content: z.array(MessageContentSchema).min(1),

  // Reply to specific message
  replyTo: z.string().optional(),

  // Formatting hints
  format: z.enum(['plain', 'markdown', 'html']).default('markdown'),

  // Channel-specific options
  options: z.record(z.unknown()).optional(),
})

export type OutgoingMessage = z.infer<typeof OutgoingMessageSchema>

// Normalized message (internal representation)
export const NormalizedMessageSchema = z.object({
  id: InternalIdSchema,              // Internal UUID (generated by meao)

  // Mapping to platform
  channelId: z.string(),
  platformMessageId: PlatformIdSchema, // Original platform message ID

  // User (resolved from sender)
  userId: InternalIdSchema,          // References User.id
  sessionId: InternalIdSchema,       // References Session.id

  // Content
  role: z.enum(['user', 'assistant', 'system', 'tool']),
  content: z.array(MessageContentSchema),

  // For tool messages
  toolCallId: z.string().optional(),
  toolName: z.string().optional(),

  // Labeling (see LABELS.md)
  label: z.object({
    trustLevel: z.enum(['untrusted', 'verified', 'user', 'system']),
    dataClass: z.enum(['public', 'internal', 'sensitive', 'secret']),
  }),

  // Timestamps (coercible for JSON compatibility)
  timestamp: CoercibleDateSchema,

  // Metadata
  metadata: z.record(z.unknown()).optional(),
})

export type NormalizedMessage = z.infer<typeof NormalizedMessageSchema>
```

### Request Context

```typescript
// Context passed to all operations
export const RequestContextSchema = z.object({
  // Who is making the request
  userId: InternalIdSchema,
  user: UserSchema,

  // Session context
  sessionId: InternalIdSchema,
  session: SessionSchema,

  // Channel context
  channelId: z.string(),

  // Workspace for file operations
  workspace: z.string(),

  // Approvals granted in this session
  // Stored as array for JSON serialization; convert to Set at runtime
  approvals: z.array(z.string()),

  // Request tracing
  requestId: InternalIdSchema,
  timestamp: CoercibleDateSchema,
})

export type RequestContext = z.infer<typeof RequestContextSchema>

// Runtime helper to check approvals
export function hasApproval(context: RequestContext, approval: string): boolean {
  return context.approvals.includes(approval)
}

// Runtime helper to create Set from approvals (for O(1) lookups in hot paths)
export function getApprovalsSet(context: RequestContext): Set<string> {
  return new Set(context.approvals)
}
```

---

## Channel Plugin

Channels connect meao to messaging platforms.

### Channel Interface

```typescript
// Health status
export const HealthStatusSchema = z.object({
  healthy: z.boolean(),
  message: z.string().optional(),
  lastCheck: CoercibleDateSchema,
  details: z.record(z.unknown()).optional(),
})

export type HealthStatus = z.infer<typeof HealthStatusSchema>

// Channel configuration (base)
export const ChannelConfigSchema = z.object({
  enabled: z.boolean().default(true),

  // DM policy
  dmPolicy: z.enum([
    'owner_only',      // Only owner can DM
    'allowlist',       // Only allowed users
    'pairing',         // Require pairing code
    'open',            // Anyone (dangerous)
  ]).default('owner_only'),

  // Allowed users (for 'allowlist' policy)
  allowedUsers: z.array(z.string()).optional(),

  // Rate limiting
  rateLimit: z.object({
    maxPerMinute: z.number().int().positive().default(30),
    maxPerHour: z.number().int().positive().default(500),
  }).optional(),
})

export type ChannelConfig = z.infer<typeof ChannelConfigSchema>

// Message handler signature
export type MessageHandler = (message: IncomingMessage) => Promise<void>

// Channel plugin interface
export interface ChannelPlugin {
  // Identity
  readonly id: string           // 'telegram', 'cli', 'discord'
  readonly name: string         // 'Telegram Bot'
  readonly version: string      // SemVer

  // Lifecycle
  initialize(config: ChannelConfig): Promise<void>
  start(): Promise<void>
  stop(): Promise<void>
  healthCheck(): Promise<HealthStatus>

  // Message handling
  onMessage(handler: MessageHandler): void

  // Sending
  send(
    conversationId: string,
    message: OutgoingMessage
  ): Promise<{ messageId: string }>

  // Optional: Typing indicators
  sendTyping?(conversationId: string): Promise<void>

  // Optional: Message editing
  editMessage?(
    conversationId: string,
    messageId: string,
    message: OutgoingMessage
  ): Promise<void>

  // Optional: Message deletion
  deleteMessage?(
    conversationId: string,
    messageId: string
  ): Promise<void>

  // Optional: User lookup
  getUser?(platformUserId: string): Promise<{
    id: string
    username?: string
    displayName?: string
  } | null>
}
```

### Channel-Specific Configs

```typescript
// Telegram channel
export const TelegramConfigSchema = ChannelConfigSchema.extend({
  botToken: z.string().min(1),

  // Polling or webhook
  mode: z.enum(['polling', 'webhook']).default('polling'),

  // Webhook settings (if mode is 'webhook')
  webhook: z.object({
    url: z.string().url(),
    secretToken: z.string().optional(),
  }).optional(),

  // Bot settings
  parseMode: z.enum(['HTML', 'Markdown', 'MarkdownV2']).default('MarkdownV2'),
})

export type TelegramConfig = z.infer<typeof TelegramConfigSchema>

// Discord channel
export const DiscordConfigSchema = ChannelConfigSchema.extend({
  botToken: z.string().min(1),

  // Guild/server restrictions
  allowedGuilds: z.array(z.string()).optional(),

  // Channel restrictions
  allowedChannels: z.array(z.string()).optional(),

  // Intents needed
  intents: z.array(z.string()).default(['Guilds', 'GuildMessages', 'DirectMessages']),
})

export type DiscordConfig = z.infer<typeof DiscordConfigSchema>

// CLI channel
export const CLIConfigSchema = ChannelConfigSchema.extend({
  // Prompt customization
  prompt: z.string().default('meao> '),

  // Output settings
  colors: z.boolean().default(true),
  markdown: z.boolean().default(true),

  // History
  historyFile: z.string().optional(),
  historySize: z.number().int().positive().default(1000),
})

export type CLIConfig = z.infer<typeof CLIConfigSchema>
```

---

## Skill Plugin

Skills provide domain expertise with specialized prompts and tools.

### Skill Interface

```typescript
// Skill match result
export const SkillMatchSchema = z.object({
  matches: z.boolean(),
  confidence: z.number().min(0).max(1),
  reason: z.string().optional(),
})

export type SkillMatch = z.infer<typeof SkillMatchSchema>

// Conversation context for skill matching
export const ConversationContextSchema = z.object({
  // Recent messages
  messages: z.array(NormalizedMessageSchema),

  // Current session
  session: SessionSchema,

  // User preferences
  userPreferences: z.record(z.unknown()).optional(),

  // Retrieved memories
  memories: z.array(z.object({
    content: z.string(),
    source: z.string(),
    relevance: z.number(),
  })).optional(),
})

export type ConversationContext = z.infer<typeof ConversationContextSchema>

// Skill configuration
export const SkillConfigSchema = z.object({
  enabled: z.boolean().default(true),

  // Priority for skill selection (higher = preferred)
  priority: z.number().int().default(0),

  // Custom settings per skill
  settings: z.record(z.unknown()).optional(),
})

export type SkillConfig = z.infer<typeof SkillConfigSchema>

// Skill plugin interface
export interface SkillPlugin {
  // Identity
  readonly id: string              // 'coder', 'research', 'calendar'
  readonly name: string            // 'Coding Assistant'
  readonly description: string     // For AI to understand when to use
  readonly version: string         // SemVer

  // Lifecycle
  initialize(config: SkillConfig): Promise<void>

  // Skill selection
  match(context: ConversationContext): Promise<SkillMatch>

  // What this skill provides
  readonly systemPrompt: string
  readonly tools: ToolPlugin[]

  // Optional: Skill-specific memory retrieval
  getMemory?(context: ConversationContext): Promise<Array<{
    content: string
    source: string
    relevance: number
  }>>

  // Optional: Pre-process user message
  preProcess?(message: NormalizedMessage): Promise<NormalizedMessage>

  // Optional: Post-process AI response
  postProcess?(response: string): Promise<string>

  // Optional: Custom context building
  buildContext?(context: ConversationContext): Promise<string>
}
```

### Built-in Skills

```typescript
// Coder skill config
export const CoderSkillConfigSchema = SkillConfigSchema.extend({
  settings: z.object({
    // Languages to prioritize
    languages: z.array(z.string()).default(['typescript', 'python']),

    // Code style preferences
    style: z.object({
      indentation: z.enum(['tabs', 'spaces']).default('spaces'),
      indentSize: z.number().int().min(1).max(8).default(2),
      lineLength: z.number().int().min(40).max(200).default(100),
    }).optional(),

    // Test preferences
    testing: z.object({
      framework: z.string().optional(),
      coverage: z.boolean().default(false),
    }).optional(),
  }).optional(),
})

// Research skill config
export const ResearchSkillConfigSchema = SkillConfigSchema.extend({
  settings: z.object({
    // Preferred sources
    trustedDomains: z.array(z.string()).optional(),

    // Citation style
    citationStyle: z.enum(['inline', 'footnote', 'none']).default('inline'),

    // Depth of research
    depth: z.enum(['quick', 'moderate', 'thorough']).default('moderate'),
  }).optional(),
})
```

---

## Tool Plugin

Tools are atomic operations the AI can perform.

### Tool Interface

```typescript
// JSON Schema for parameters (subset we support)
export const JSONSchemaSchema: z.ZodType<JSONSchema> = z.lazy(() =>
  z.object({
    type: z.enum(['string', 'number', 'integer', 'boolean', 'array', 'object']),
    description: z.string().optional(),
    enum: z.array(z.unknown()).optional(),
    default: z.unknown().optional(),

    // String constraints
    minLength: z.number().int().optional(),
    maxLength: z.number().int().optional(),
    pattern: z.string().optional(),

    // Number constraints
    minimum: z.number().optional(),
    maximum: z.number().optional(),

    // Array constraints
    items: JSONSchemaSchema.optional(),
    minItems: z.number().int().optional(),
    maxItems: z.number().int().optional(),

    // Object constraints
    properties: z.record(JSONSchemaSchema).optional(),
    required: z.array(z.string()).optional(),
    additionalProperties: z.boolean().optional(),
  })
)

export type JSONSchema = z.infer<typeof JSONSchemaSchema>

// Tool execution result
export const ToolResultSchema = z.object({
  success: z.boolean(),

  // Output (for AI to see)
  output: z.string().optional(),

  // Structured data (optional)
  data: z.unknown().optional(),

  // Error info
  error: z.object({
    code: z.string(),
    message: z.string(),
    details: z.unknown().optional(),
  }).optional(),

  // Label for the output (see LABELS.md)
  label: z.object({
    trustLevel: z.enum(['untrusted', 'verified', 'user', 'system']),
    dataClass: z.enum(['public', 'internal', 'sensitive', 'secret']),
  }).optional(),

  // Execution metadata
  metadata: z.object({
    durationMs: z.number(),
    sandboxLevel: z.enum(['none', 'process', 'container']).optional(),
    networkMode: z.enum(['none', 'proxy', 'host']).optional(),
  }).optional(),
})

export type ToolResult = z.infer<typeof ToolResultSchema>

// Tool execution context
export const ToolContextSchema = z.object({
  // Request context
  request: RequestContextSchema,

  // Calling skill (if any)
  skillId: z.string().optional(),

  // Tool call ID (from AI)
  toolCallId: z.string(),

  // Abort signal for cancellation
  signal: z.instanceof(AbortSignal).optional(),
})

export type ToolContext = z.infer<typeof ToolContextSchema>

// Approval policy (see TOOL_CAPABILITY.md)
export const ApprovalPolicySchema = z.object({
  level: z.enum(['auto', 'ask', 'always']),
  dangerPatterns: z.array(z.instanceof(RegExp)).optional(),
  trustAfterApproval: z.boolean().default(true),
  askForMethods: z.array(z.string()).optional(),
})

// Data policy
export const DataPolicySchema = z.object({
  sensitivity: z.enum(['none', 'low', 'medium', 'high', 'secret']),
  canReadSecrets: z.boolean().default(false),
  canLeakData: z.boolean().default(false),
  sanitizeOutput: z.boolean().default(true),
})

// Network policy
export const NetworkPolicySchema = z.object({
  access: z.enum(['none', 'limited', 'full']),
  allowedHosts: z.array(z.string()).optional(),
  blockedHosts: z.array(z.string()).optional(),
  blockedPorts: z.array(z.number().int()).optional(),
  blockPrivateIPs: z.boolean().default(true),
  blockMetadata: z.boolean().default(true),
  requireApprovalForUnknownHosts: z.boolean().default(false),
})

// Execution policy (see SANDBOX.md)
export const ExecutionPolicySchema = z.object({
  sandbox: z.enum(['none', 'process', 'container']),
  networkMode: z.enum(['none', 'proxy', 'host']).optional(),
  timeout: z.number().int().positive().default(60000),
  maxOutputSize: z.number().int().positive().default(1_000_000),
  allowedPaths: z.array(z.string()).optional(),
  blockedPaths: z.array(z.string()).optional(),
  env: z.enum(['inherit', 'clean', 'explicit']).default('clean'),
  allowedEnvVars: z.array(z.string()).optional(),
})

// Audit policy
export const AuditPolicySchema = z.object({
  logArgs: z.boolean().default(true),
  logOutput: z.boolean().default(false),
  useSharedSecretDetector: z.boolean().default(true),
  alertOn: z.array(z.string()).optional(),
})

// Label policy (see LABELS.md)
export const LabelPolicySchema = z.object({
  outputTrust: z.enum(['untrusted', 'verified', 'user', 'system']),
  outputDataClass: z.enum(['public', 'internal', 'sensitive', 'secret']),
  acceptsUntrusted: z.boolean().default(true),
})

// Full capability schema
export const ToolCapabilitySchema = z.object({
  approval: ApprovalPolicySchema,
  data: DataPolicySchema,
  network: NetworkPolicySchema,
  execution: ExecutionPolicySchema,
  audit: AuditPolicySchema,
  labels: LabelPolicySchema,
})

export type ToolCapability = z.infer<typeof ToolCapabilitySchema>

// Tool plugin interface
export interface ToolPlugin {
  // Identity
  readonly name: string           // 'bash', 'read', 'write'
  readonly description: string    // For AI to understand
  readonly version: string        // SemVer

  // Parameter schema
  readonly parameters: JSONSchema

  // Security capability
  readonly capability: ToolCapability

  // Execution
  execute(args: unknown, context: ToolContext): Promise<ToolResult>

  // Optional: Validate arguments before execution
  validate?(args: unknown): { valid: boolean; error?: string }

  // Optional: Preview what would happen (dry run)
  preview?(args: unknown, context: ToolContext): Promise<string>
}
```

### Built-in Tool Schemas

```typescript
// read tool arguments
export const ReadArgsSchema = z.object({
  path: z.string().min(1),
  encoding: z.enum(['utf8', 'base64', 'binary']).default('utf8'),
  maxSize: z.number().int().positive().optional(),
})

// write tool arguments
export const WriteArgsSchema = z.object({
  path: z.string().min(1),
  content: z.string(),
  encoding: z.enum(['utf8', 'base64']).default('utf8'),
  createDirs: z.boolean().default(true),
  overwrite: z.boolean().default(true),
})

// edit tool arguments
export const EditArgsSchema = z.object({
  path: z.string().min(1),
  edits: z.array(z.object({
    oldText: z.string(),
    newText: z.string(),
  })).min(1),
})

// bash tool arguments
export const BashArgsSchema = z.object({
  command: z.string().min(1),
  cwd: z.string().optional(),
  env: z.record(z.string()).optional(),
  timeout: z.number().int().positive().optional(),
})

// web_fetch tool arguments
export const WebFetchArgsSchema = z.object({
  url: z.string().url(),
  method: z.enum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']).default('GET'),
  headers: z.record(z.string()).optional(),
  body: z.string().optional(),
  timeout: z.number().int().positive().default(30000),
})

// web_search tool arguments
export const WebSearchArgsSchema = z.object({
  query: z.string().min(1).max(500),
  maxResults: z.number().int().min(1).max(20).default(10),
})
```

---

## Memory Types

See [MEMORY.md](./MEMORY.md) for full specification.

```typescript
// Memory source (for attribution)
export const MemorySourceSchema = z.object({
  type: z.enum(['user_message', 'tool_output', 'ai_inference', 'explicit_save']),
  trust: z.enum(['high', 'medium', 'low']),
  sessionId: z.string().optional(),
  messageId: z.string().optional(),
  toolName: z.string().optional(),
})

export type MemorySource = z.infer<typeof MemorySourceSchema>

// Episodic memory entry
export const EpisodicMemorySchema = z.object({
  id: InternalIdSchema,
  userId: InternalIdSchema,

  // Content
  content: z.string(),
  embedding: z.array(z.number()).optional(),

  // Context
  sessionId: InternalIdSchema,
  role: z.enum(['user', 'assistant', 'tool']),

  // Attribution
  source: MemorySourceSchema,

  // Label
  label: z.object({
    trustLevel: z.enum(['untrusted', 'verified', 'user', 'system']),
    dataClass: z.enum(['public', 'internal', 'sensitive', 'secret']),
  }),

  // Metadata
  tags: z.array(z.string()).optional(),
  fromExternalContent: z.boolean().default(false),

  // Timestamps (coercible for JSON compatibility)
  createdAt: CoercibleDateSchema,
  expiresAt: CoercibleDateSchema.optional(),
})

export type EpisodicMemory = z.infer<typeof EpisodicMemorySchema>

// Semantic memory entry (facts/preferences)
export const SemanticMemorySchema = z.object({
  id: InternalIdSchema,
  userId: InternalIdSchema,

  // Content
  category: z.enum(['fact', 'preference', 'instruction']),
  key: z.string(),
  value: z.string(),

  // Confidence
  confidence: z.number().min(0).max(1).default(1),

  // Attribution
  source: MemorySourceSchema,

  // Timestamps (coercible for JSON compatibility)
  createdAt: CoercibleDateSchema,
  updatedAt: CoercibleDateSchema,
})

export type SemanticMemory = z.infer<typeof SemanticMemorySchema>

// Memory query
export const MemoryQuerySchema = z.object({
  // Filter by user (required)
  userId: InternalIdSchema,

  // Semantic search
  query: z.string().optional(),
  embedding: z.array(z.number()).optional(),

  // Filters
  sessionId: InternalIdSchema.optional(),
  role: z.enum(['user', 'assistant', 'tool']).optional(),
  category: z.enum(['fact', 'preference', 'instruction']).optional(),
  tags: z.array(z.string()).optional(),

  // Time range (coercible for JSON compatibility)
  since: CoercibleDateSchema.optional(),
  until: CoercibleDateSchema.optional(),

  // Pagination
  limit: z.number().int().min(1).max(100).default(10),
  offset: z.number().int().min(0).default(0),
})

export type MemoryQuery = z.infer<typeof MemoryQuerySchema>
```

---

## Provider Types

AI provider abstraction.

```typescript
// Provider message format
export const ProviderMessageSchema = z.object({
  role: z.enum(['user', 'assistant', 'system']),
  content: z.string(),

  // For tool calls from AI
  toolCalls: z.array(z.object({
    id: z.string(),
    name: z.string(),
    // Arguments are a JSON string - this is how most providers return them.
    // IMPORTANT: Implementers must JSON.parse() and validate against
    // ToolPlugin.parameters before executing. Never trust raw arguments.
    arguments: z.string(),
  })).optional(),

  // For tool results (sent back to AI)
  toolResults: z.array(z.object({
    toolCallId: z.string(),
    content: z.string(),
  })).optional(),
})

export type ProviderMessage = z.infer<typeof ProviderMessageSchema>

// Helper to parse and validate tool arguments
export async function parseToolArguments<T>(
  argsJson: string,
  schema: z.ZodSchema<T>
): Promise<{ success: true; data: T } | { success: false; error: string }> {
  try {
    const parsed = JSON.parse(argsJson)
    const result = schema.safeParse(parsed)
    if (result.success) {
      return { success: true, data: result.data }
    }
    return { success: false, error: result.error.message }
  } catch (e) {
    return { success: false, error: `Invalid JSON: ${e}` }
  }
}

// Tool definition for provider
export const ProviderToolSchema = z.object({
  name: z.string(),
  description: z.string(),
  parameters: JSONSchemaSchema,
})

export type ProviderTool = z.infer<typeof ProviderToolSchema>

// Streaming event types
export const StreamEventSchema = z.discriminatedUnion('type', [
  z.object({
    type: z.literal('text_delta'),
    text: z.string(),
  }),
  z.object({
    type: z.literal('tool_call_start'),
    toolCallId: z.string(),
    toolName: z.string(),
  }),
  z.object({
    type: z.literal('tool_call_delta'),
    toolCallId: z.string(),
    argumentsDelta: z.string(),
  }),
  z.object({
    type: z.literal('tool_call_end'),
    toolCallId: z.string(),
  }),
  z.object({
    type: z.literal('message_end'),
    usage: z.object({
      inputTokens: z.number().int(),
      outputTokens: z.number().int(),
    }),
  }),
  z.object({
    type: z.literal('error'),
    error: z.object({
      code: z.string(),
      message: z.string(),
    }),
  }),
])

export type StreamEvent = z.infer<typeof StreamEventSchema>

// Provider configuration
export const ProviderConfigSchema = z.object({
  // Provider type
  type: z.enum(['anthropic', 'openai', 'ollama']),

  // API key (for cloud providers)
  apiKey: z.string().optional(),

  // Base URL (for Ollama or custom endpoints)
  baseUrl: z.string().url().optional(),

  // Model selection
  model: z.string(),

  // Generation settings
  maxTokens: z.number().int().positive().default(4096),
  temperature: z.number().min(0).max(2).default(0.7),

  // Retry settings
  maxRetries: z.number().int().min(0).max(10).default(3),
  retryDelay: z.number().int().positive().default(1000),

  // Timeout
  timeout: z.number().int().positive().default(120000),
})

export type ProviderConfig = z.infer<typeof ProviderConfigSchema>

// Provider interface
export interface AIProvider {
  // Identity
  readonly type: 'anthropic' | 'openai' | 'ollama'
  readonly name: string

  // Lifecycle
  initialize(config: ProviderConfig): Promise<void>

  // Generation
  stream(
    messages: ProviderMessage[],
    tools: ProviderTool[],
    options?: {
      systemPrompt?: string
      maxTokens?: number
      temperature?: number
      signal?: AbortSignal
    }
  ): AsyncIterable<StreamEvent>

  // Utilities
  countTokens(text: string): Promise<number>

  // Embeddings (for memory)
  embed(text: string): Promise<number[]>

  // Health check
  healthCheck(): Promise<HealthStatus>
}
```

---

## Event Types

Internal event bus for component communication.

```typescript
// Event base
export const EventBaseSchema = z.object({
  id: InternalIdSchema,
  timestamp: CoercibleDateSchema,
  source: z.string(),  // Component that emitted
})

// Message events
export const MessageReceivedEventSchema = EventBaseSchema.extend({
  type: z.literal('message.received'),
  payload: z.object({
    message: IncomingMessageSchema,
  }),
})

export const MessageSentEventSchema = EventBaseSchema.extend({
  type: z.literal('message.sent'),
  payload: z.object({
    channelId: z.string(),
    conversationId: z.string(),
    messageId: z.string(),
    content: z.array(MessageContentSchema),
  }),
})

// Session events
export const SessionStartedEventSchema = EventBaseSchema.extend({
  type: z.literal('session.started'),
  payload: z.object({
    session: SessionSchema,
  }),
})

export const SessionEndedEventSchema = EventBaseSchema.extend({
  type: z.literal('session.ended'),
  payload: z.object({
    sessionId: z.string(),
    reason: z.enum(['timeout', 'user_ended', 'error']),
  }),
})

// Tool events
export const ToolExecutionStartedEventSchema = EventBaseSchema.extend({
  type: z.literal('tool.execution.started'),
  payload: z.object({
    toolCallId: z.string(),
    toolName: z.string(),
    sessionId: z.string(),
  }),
})

export const ToolExecutionCompletedEventSchema = EventBaseSchema.extend({
  type: z.literal('tool.execution.completed'),
  payload: z.object({
    toolCallId: z.string(),
    toolName: z.string(),
    success: z.boolean(),
    durationMs: z.number(),
  }),
})

export const ToolApprovalRequestedEventSchema = EventBaseSchema.extend({
  type: z.literal('tool.approval.requested'),
  payload: z.object({
    toolCallId: z.string(),
    toolName: z.string(),
    args: z.unknown(),
    reason: z.string(),
  }),
})

export const ToolApprovalResponseEventSchema = EventBaseSchema.extend({
  type: z.literal('tool.approval.response'),
  payload: z.object({
    toolCallId: z.string(),
    approved: z.boolean(),
    userId: z.string(),
  }),
})

// All events
export const EventSchema = z.discriminatedUnion('type', [
  MessageReceivedEventSchema,
  MessageSentEventSchema,
  SessionStartedEventSchema,
  SessionEndedEventSchema,
  ToolExecutionStartedEventSchema,
  ToolExecutionCompletedEventSchema,
  ToolApprovalRequestedEventSchema,
  ToolApprovalResponseEventSchema,
])

export type Event = z.infer<typeof EventSchema>

// Event handler signature
export type EventHandler<T extends Event = Event> = (event: T) => Promise<void>

// Event bus interface
export interface EventBus {
  emit(event: Omit<Event, 'id' | 'timestamp'>): Promise<void>
  on<T extends Event['type']>(
    type: T,
    handler: EventHandler<Extract<Event, { type: T }>>
  ): () => void  // Returns unsubscribe function
  once<T extends Event['type']>(
    type: T,
    handler: EventHandler<Extract<Event, { type: T }>>
  ): () => void
}
```

---

## Configuration

Main application configuration.

```typescript
// Full application config
export const AppConfigSchema = z.object({
  // Version (for migrations)
  version: z.number().int().positive(),

  // Owner info
  owner: z.object({
    userId: z.string().uuid(),
    displayName: z.string(),
  }),

  // Key management (see KEY_MANAGEMENT.md)
  keyManagement: z.object({
    kekSource: z.enum(['passphrase', 'keychain']),
    kdfConfig: z.object({
      memoryCost: z.number().int().positive().default(65536),
      timeCost: z.number().int().positive().default(3),
      parallelism: z.number().int().positive().default(4),
    }).optional(),
  }),

  // Channels
  channels: z.record(z.union([
    TelegramConfigSchema,
    DiscordConfigSchema,
    CLIConfigSchema,
    ChannelConfigSchema,  // Base for unknown channels
  ])),

  // Skills
  skills: z.record(SkillConfigSchema),

  // Tools
  tools: z.record(z.object({
    enabled: z.boolean().default(true),
    capability: ToolCapabilitySchema.partial().optional(),
  })),

  // AI Providers
  providers: z.object({
    primary: ProviderConfigSchema,
    fallback: ProviderConfigSchema.optional(),
    offline: ProviderConfigSchema.optional(),
  }),

  // Memory settings
  memory: z.object({
    // Episodic
    episodic: z.object({
      enabled: z.boolean().default(true),
      ttlDays: z.number().int().positive().default(90),
      maxEntries: z.number().int().positive().default(10000),
    }),
    // Semantic
    semantic: z.object({
      enabled: z.boolean().default(true),
      maxEntries: z.number().int().positive().default(1000),
    }),
    // Embeddings
    embeddings: z.object({
      provider: z.enum(['openai', 'ollama', 'local']).default('openai'),
      model: z.string().default('text-embedding-3-small'),
    }),
  }),

  // Sandbox settings (see SANDBOX.md)
  sandbox: z.object({
    bash: z.object({
      defaultNetwork: z.enum(['none', 'proxy']).default('none'),
      proxyAllowlist: z.array(z.string()).optional(),
      resources: z.object({
        memory: z.string().default('512m'),
        cpus: z.number().positive().default(1),
        timeout: z.number().int().positive().default(120000),
      }).optional(),
    }).optional(),
    images: z.object({
      default: z.string().default('meao-sandbox:latest'),
    }).optional(),
  }).optional(),

  // Logging
  logging: z.object({
    level: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
    file: z.string().optional(),
    maxSize: z.string().default('10m'),
    maxFiles: z.number().int().positive().default(5),
  }),

  // Server
  server: z.object({
    host: z.string().default('127.0.0.1'),
    port: z.number().int().min(1).max(65535).default(3000),
    cors: z.object({
      enabled: z.boolean().default(false),
      origins: z.array(z.string()).optional(),
    }).optional(),
  }),
})

export type AppConfig = z.infer<typeof AppConfigSchema>
```

---

## Versioning Policy

### Interface Stability

| Stability | Meaning | Breaking Changes |
|-----------|---------|------------------|
| **Stable** | Production ready | Major version only |
| **Beta** | Feature complete, may change | Minor version |
| **Alpha** | Experimental | Any version |

### Current Status

| Interface | Stability | Notes |
|-----------|-----------|-------|
| ChannelPlugin | **Stable** | Core messaging contract |
| SkillPlugin | Beta | May add hooks |
| ToolPlugin | **Stable** | Security-critical |
| ToolCapability | **Stable** | Security-critical |
| MemoryTypes | Beta | May evolve with use |
| ProviderTypes | Beta | May add providers |
| EventTypes | Alpha | Adding as needed |
| AppConfig | Beta | May add sections |

### Breaking Change Policy

1. **Stable interfaces**: Breaking changes require major version bump and 3-month deprecation
2. **Beta interfaces**: Breaking changes in minor versions, documented in changelog
3. **Alpha interfaces**: May change without notice

### Deprecation Process

```typescript
/**
 * @deprecated Since 1.2.0. Use `newMethod()` instead. Will be removed in 2.0.0.
 */
oldMethod(): void

// Runtime warning
function oldMethod() {
  console.warn('oldMethod is deprecated. Use newMethod instead.')
  // ... implementation
}
```

---

## Export Index

```typescript
// src/interfaces/index.ts

// Core types and helpers
export * from './core/ids'           // InternalIdSchema, PlatformIdSchema
export * from './core/dates'         // CoercibleDateSchema
export * from './core/user'          // UserSchema, isOwner
export * from './core/session'       // SessionSchema
export * from './core/message'       // MessageContentSchema, IncomingMessageSchema, etc.
export * from './core/context'       // RequestContextSchema, hasApproval, getApprovalsSet

// Plugins
export * from './plugins/channel'    // ChannelPlugin, ChannelConfigSchema, etc.
export * from './plugins/skill'      // SkillPlugin, SkillConfigSchema, etc.
export * from './plugins/tool'       // ToolPlugin, ToolCapabilitySchema, etc.

// Memory
export * from './memory/types'       // EpisodicMemorySchema, SemanticMemorySchema
export * from './memory/query'       // MemoryQuerySchema

// Provider
export * from './provider/types'     // ProviderMessageSchema, StreamEventSchema
export * from './provider/config'    // ProviderConfigSchema
export * from './provider/helpers'   // parseToolArguments

// Events
export * from './events/types'       // EventSchema, all event types
export * from './events/bus'         // EventBus, EventHandler

// Config
export * from './config/app'         // AppConfigSchema

// Utilities
export * from './utils/json-schema'  // JSONSchemaSchema
export * from './utils/validation'   // Validation helpers
```

---

*This specification is living documentation. Update as interfaces evolve.*

*Last updated: 2026-01-29*
