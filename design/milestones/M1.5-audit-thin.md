# Milestone 1.5: Audit (Thin Logger)

**Status:** NOT STARTED
**Scope:** MVP
**Dependencies:** M1 (Config)
**PR:** PR2

---

## Goal

Get observability early with minimal coupling. Audit traces help debug config, security, and tool issues from day one. This is a thin implementation - just enough to log and enforce NEVER_LOG.

**Why before Security Primitives?** You need audit logging as soon as you start building enforcement. Even M2 (SecretDetector) benefits from audit traces during development.

**Spec Reference:** [AUDIT.md](../AUDIT.md)

---

## File Structure

```
src/audit/
├── index.ts                   # Public exports
├── types.ts                   # AuditEntry, AuditCategory, AuditSeverity
├── schema.ts                  # Zod schemas for entries
├── redaction.ts               # NEVER_LOG enforcement (simple truncation)
├── store/
│   ├── interface.ts           # AuditStore interface
│   └── jsonl.ts               # JSONL implementation
└── service.ts                 # AuditLogger class
```

---

## Key Exports

```typescript
// src/audit/index.ts
// CANONICAL EXPORTS: AuditEntry comes from schema.ts (via Zod inference)
export { AuditLogger, getAuditLogger } from './service'
export { AuditEntrySchema, type AuditEntry } from './schema'
export { type AuditCategory, type AuditSeverity } from './types'
export { sanitizeAuditEntry } from './redaction'
export { JsonlAuditStore } from './store/jsonl'
```

---

## Implementation Requirements

### 1. Types (types.ts)

**CANONICAL SOURCE:** `AuditEntry` is defined in `schema.ts` via Zod and re-exported from `index.ts`.

```typescript
// types.ts - Only contains type aliases, not AuditEntry
export type AuditCategory =
  | 'auth'      // login, logout, pairing
  | 'tool'      // Tool execution
  | 'memory'    // Memory operations
  | 'label'     // Label changes
  | 'channel'   // Channel events
  | 'config'    // Config changes
  | 'sandbox'   // Sandbox enforcement

export type AuditSeverity = 'debug' | 'info' | 'warning' | 'alert' | 'critical'

// NOTE: AuditEntry is defined in schema.ts and re-exported from index.ts
// DO NOT define AuditEntry here to avoid duplicate types
```

### 2. NEVER_LOG Enforcement (redaction.ts)

This is the **most critical** part of M1.5. These fields must NEVER appear in audit logs.

**IMPORTANT:** Paths are relative to the AuditEntry root object (include the `metadata.` prefix).

```typescript
// Fields that must NEVER appear in audit logs
// Paths are RELATIVE TO ROOT (e.g., entry.metadata.message.content)
// NOT relative to metadata - the 'metadata.' prefix is part of the path
const NEVER_LOG_FIELDS = [
  'metadata.message.content',   // User message text
  'metadata.tool.output',       // Raw tool output
  'metadata.file.content',      // File contents
  'metadata.memory.content',    // Memory entry content
  'metadata.response.text',     // AI response text
]

export function sanitizeAuditEntry(entry: AuditEntry): AuditEntry {
  // Deep clone to avoid mutation
  const sanitized = structuredClone(entry)

  // Remove forbidden fields
  for (const field of NEVER_LOG_FIELDS) {
    deletePath(sanitized, field)
  }

  // Simple truncation for error messages
  // (SecretDetector integration added in M3)
  if (sanitized.metadata?.errorMessage) {
    sanitized.metadata.errorMessage = String(
      sanitized.metadata.errorMessage
    ).slice(0, 500)
  }

  return sanitized
}

// Helper to delete nested path from root object
function deletePath(obj: Record<string, unknown>, path: string): void {
  const parts = path.split('.')
  let current = obj

  for (let i = 0; i < parts.length - 1; i++) {
    const part = parts[i]
    if (current[part] === undefined || typeof current[part] !== 'object') {
      return
    }
    current = current[part] as Record<string, unknown>
  }

  delete current[parts[parts.length - 1]]
}
```

### 3. Schema with Coerced Date (schema.ts)

**IMPORTANT:** JSON serialization converts `Date` to ISO string. We need Zod to coerce it back.

```typescript
import { z } from 'zod'

// Use z.coerce.date() to handle JSON string → Date conversion
export const AuditEntrySchema = z.object({
  id: z.string(),
  timestamp: z.coerce.date(),  // Handles both Date and ISO string
  category: z.enum(['auth', 'tool', 'memory', 'label', 'channel', 'config', 'sandbox']),
  action: z.string(),
  severity: z.enum(['debug', 'info', 'warning', 'alert', 'critical']),
  requestId: z.string().optional(),
  sessionId: z.string().optional(),
  userId: z.string().optional(),
  metadata: z.record(z.unknown()).optional(),
})

export type AuditEntry = z.infer<typeof AuditEntrySchema>
```

### 4. JSONL Store (store/jsonl.ts)

```typescript
import { promises as fs } from 'fs'
import path from 'path'
import { AuditEntry, AuditEntrySchema } from '../schema'
import { sanitizeAuditEntry } from '../redaction'
import { getAuditPath } from '../../config'

export interface AuditStore {
  append(entry: AuditEntry): Promise<void>
  query(filter: AuditFilter): Promise<AuditEntry[]>
}

export interface AuditFilter {
  since?: Date
  until?: Date
  category?: AuditCategory
  action?: string
  severity?: AuditSeverity
  limit?: number
}

export class JsonlAuditStore implements AuditStore {
  private basePath: string

  constructor(basePath?: string) {
    this.basePath = basePath ?? getAuditPath()
  }

  async append(entry: AuditEntry): Promise<void> {
    // ALWAYS sanitize before writing
    const sanitized = sanitizeAuditEntry(entry)

    const filename = this.getDailyFilename()
    const filepath = path.join(this.basePath, filename)

    // Ensure directory exists
    await fs.mkdir(this.basePath, { recursive: true })

    // Append line (Date becomes ISO string via JSON.stringify)
    const line = JSON.stringify(sanitized) + '\n'
    await fs.appendFile(filepath, line, { encoding: 'utf-8' })
  }

  async query(filter: AuditFilter): Promise<AuditEntry[]> {
    const results: AuditEntry[] = []
    // MVP: Returns all files, filtering happens per-entry in matchesFilter()
    // Phase 2: Optimize by filtering files based on date range
    const files = await this.getAllAuditFiles()

    for (const file of files) {
      const content = await fs.readFile(file, 'utf-8')
      const lines = content.trim().split('\n').filter(Boolean)

      for (const line of lines) {
        // Parse through Zod to coerce timestamp string back to Date
        const raw = JSON.parse(line)
        const entry = AuditEntrySchema.parse(raw)

        if (this.matchesFilter(entry, filter)) {
          results.push(entry)

          if (filter.limit && results.length >= filter.limit) {
            return results
          }
        }
      }
    }

    return results
  }

  private getDailyFilename(): string {
    const date = new Date().toISOString().slice(0, 10)
    return `audit-${date}.jsonl`
  }

  // MVP: Returns all audit files (date filtering done in matchesFilter)
  // Phase 2: Optimize to filter files by filename date
  private async getAllAuditFiles(): Promise<string[]> {
    const files = await fs.readdir(this.basePath)
    return files
      .filter(f => f.startsWith('audit-') && f.endsWith('.jsonl'))
      .map(f => path.join(this.basePath, f))
      .sort()
  }

  private matchesFilter(entry: AuditEntry, filter: AuditFilter): boolean {
    if (filter.category && entry.category !== filter.category) return false
    if (filter.action && entry.action !== filter.action) return false
    if (filter.severity && entry.severity !== filter.severity) return false
    // entry.timestamp is now a proper Date thanks to z.coerce.date()
    if (filter.since && entry.timestamp < filter.since) return false
    if (filter.until && entry.timestamp > filter.until) return false
    return true
  }
}
```

### 5. Audit Logger Service (service.ts)

```typescript
import { randomUUID } from 'crypto'
import { AuditEntry, AuditCategory, AuditSeverity } from './types'
import { AuditStore, JsonlAuditStore } from './store/jsonl'

export class AuditLogger {
  private store: AuditStore

  constructor(store?: AuditStore) {
    this.store = store ?? new JsonlAuditStore()
  }

  async log(
    category: AuditCategory,
    action: string,
    options: {
      severity?: AuditSeverity
      requestId?: string
      sessionId?: string
      userId?: string
      metadata?: Record<string, unknown>
    } = {}
  ): Promise<void> {
    const entry: AuditEntry = {
      id: randomUUID(),
      timestamp: new Date(),
      category,
      action,
      severity: options.severity ?? 'info',
      requestId: options.requestId,
      sessionId: options.sessionId,
      userId: options.userId,
      metadata: options.metadata,
    }

    await this.store.append(entry)
  }

  // Convenience methods
  async info(category: AuditCategory, action: string, metadata?: Record<string, unknown>): Promise<void> {
    await this.log(category, action, { severity: 'info', metadata })
  }

  async warning(category: AuditCategory, action: string, metadata?: Record<string, unknown>): Promise<void> {
    await this.log(category, action, { severity: 'warning', metadata })
  }

  async alert(category: AuditCategory, action: string, metadata?: Record<string, unknown>): Promise<void> {
    await this.log(category, action, { severity: 'alert', metadata })
  }

  async critical(category: AuditCategory, action: string, metadata?: Record<string, unknown>): Promise<void> {
    await this.log(category, action, { severity: 'critical', metadata })
  }
}

// Singleton for easy access
let auditLogger: AuditLogger | null = null

export function getAuditLogger(): AuditLogger {
  if (!auditLogger) {
    auditLogger = new AuditLogger()
  }
  return auditLogger
}
```

---

## Tests

```
test/audit/
├── never_log.test.ts          # CRITICAL: NEVER_LOG enforcement
├── jsonl.test.ts              # Basic append + daily rotation
└── schema.test.ts             # Entry validation
```

### CRITICAL Test: NEVER_LOG Enforcement

This test **MUST pass before any PR can be merged**. It's a guardrail against accidentally logging sensitive content.

```typescript
// test/audit/never_log.test.ts
import { describe, it, expect } from 'vitest'
import { sanitizeAuditEntry } from '../../src/audit/redaction'
import { AuditEntry } from '../../src/audit/types'

describe('NEVER_LOG enforcement', () => {
  it('removes message.content even if caller provides it', () => {
    const entry: AuditEntry = {
      id: '1',
      timestamp: new Date(),
      category: 'channel',
      action: 'message_received',
      severity: 'info',
      metadata: {
        message: {
          id: 'msg-1',
          content: 'This is a secret user message that should NEVER be logged',
        },
      },
    }

    const sanitized = sanitizeAuditEntry(entry)

    // Content must be removed
    expect(sanitized.metadata?.message?.content).toBeUndefined()
    // Other metadata preserved
    expect(sanitized.metadata?.message?.id).toBe('msg-1')
  })

  it('removes tool.output', () => {
    const entry: AuditEntry = {
      id: '2',
      timestamp: new Date(),
      category: 'tool',
      action: 'tool_executed',
      severity: 'info',
      metadata: {
        tool: {
          name: 'read',
          output: 'SECRET FILE CONTENTS THAT SHOULD NEVER BE LOGGED',
        },
      },
    }

    const sanitized = sanitizeAuditEntry(entry)

    expect(sanitized.metadata?.tool?.output).toBeUndefined()
    expect(sanitized.metadata?.tool?.name).toBe('read')
  })

  it('removes file.content', () => {
    const entry: AuditEntry = {
      id: '3',
      timestamp: new Date(),
      category: 'tool',
      action: 'file_read',
      severity: 'info',
      metadata: {
        file: {
          path: '/etc/passwd',
          content: 'root:x:0:0:...',
        },
      },
    }

    const sanitized = sanitizeAuditEntry(entry)

    expect(sanitized.metadata?.file?.content).toBeUndefined()
    expect(sanitized.metadata?.file?.path).toBe('/etc/passwd')
  })

  it('removes memory.content', () => {
    const entry: AuditEntry = {
      id: '4',
      timestamp: new Date(),
      category: 'memory',
      action: 'memory_write',
      severity: 'info',
      metadata: {
        memory: {
          type: 'episodic',
          content: 'User told me their password is hunter2',
        },
      },
    }

    const sanitized = sanitizeAuditEntry(entry)

    expect(sanitized.metadata?.memory?.content).toBeUndefined()
  })

  it('removes response.text', () => {
    const entry: AuditEntry = {
      id: '5',
      timestamp: new Date(),
      category: 'channel',
      action: 'response_sent',
      severity: 'info',
      metadata: {
        response: {
          id: 'resp-1',
          text: 'Here is your API key: sk-ant-xxx',
        },
      },
    }

    const sanitized = sanitizeAuditEntry(entry)

    expect(sanitized.metadata?.response?.text).toBeUndefined()
  })

  it('truncates errorMessage to 500 chars', () => {
    const longError = 'x'.repeat(1000)
    const entry: AuditEntry = {
      id: '6',
      timestamp: new Date(),
      category: 'tool',
      action: 'tool_failed',
      severity: 'alert',
      metadata: {
        errorMessage: longError,
      },
    }

    const sanitized = sanitizeAuditEntry(entry)

    expect(sanitized.metadata?.errorMessage).toHaveLength(500)
  })

  it('preserves non-sensitive metadata', () => {
    const entry: AuditEntry = {
      id: '7',
      timestamp: new Date(),
      category: 'tool',
      action: 'tool_executed',
      severity: 'info',
      requestId: 'req-123',
      sessionId: 'sess-456',
      userId: 'user-789',
      metadata: {
        tool: {
          name: 'web_fetch',
          duration: 1234,
          statusCode: 200,
        },
      },
    }

    const sanitized = sanitizeAuditEntry(entry)

    expect(sanitized.requestId).toBe('req-123')
    expect(sanitized.sessionId).toBe('sess-456')
    expect(sanitized.userId).toBe('user-789')
    expect(sanitized.metadata?.tool?.name).toBe('web_fetch')
    expect(sanitized.metadata?.tool?.duration).toBe(1234)
  })
})
```

### JSONL Store Tests

```typescript
// test/audit/jsonl.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { promises as fs } from 'fs'
import path from 'path'
import { JsonlAuditStore } from '../../src/audit/store/jsonl'

describe('JsonlAuditStore', () => {
  const testDir = '/tmp/meao-audit-test'
  let store: JsonlAuditStore

  beforeEach(async () => {
    await fs.mkdir(testDir, { recursive: true })
    store = new JsonlAuditStore(testDir)
  })

  afterEach(async () => {
    await fs.rm(testDir, { recursive: true, force: true })
  })

  it('creates daily rotation file', async () => {
    await store.append({
      id: '1',
      timestamp: new Date(),
      category: 'tool',
      action: 'test',
      severity: 'info',
    })

    const files = await fs.readdir(testDir)
    expect(files.length).toBe(1)
    expect(files[0]).toMatch(/^audit-\d{4}-\d{2}-\d{2}\.jsonl$/)
  })

  it('appends entries as JSONL', async () => {
    await store.append({
      id: '1',
      timestamp: new Date(),
      category: 'tool',
      action: 'test1',
      severity: 'info',
    })

    await store.append({
      id: '2',
      timestamp: new Date(),
      category: 'tool',
      action: 'test2',
      severity: 'info',
    })

    const files = await fs.readdir(testDir)
    const content = await fs.readFile(path.join(testDir, files[0]), 'utf-8')
    const lines = content.trim().split('\n')

    expect(lines.length).toBe(2)
    expect(JSON.parse(lines[0]).action).toBe('test1')
    expect(JSON.parse(lines[1]).action).toBe('test2')
  })

  it('queries by category', async () => {
    await store.append({ id: '1', timestamp: new Date(), category: 'tool', action: 'a', severity: 'info' })
    await store.append({ id: '2', timestamp: new Date(), category: 'auth', action: 'b', severity: 'info' })
    await store.append({ id: '3', timestamp: new Date(), category: 'tool', action: 'c', severity: 'info' })

    const results = await store.query({ category: 'tool' })

    expect(results.length).toBe(2)
    expect(results.every(r => r.category === 'tool')).toBe(true)
  })
})
```

---

## Definition of Done

- [ ] AuditLogger can append entries to JSONL
- [ ] Daily file rotation works (audit-YYYY-MM-DD.jsonl)
- [ ] NEVER_LOG fields enforced (cannot log even if passed)
- [ ] **NEVER_LOG test passes** (this is mandatory)
- [ ] Basic query functionality works
- [ ] All tests pass
- [ ] `pnpm check` passes

---

## PR Checklist

```markdown
## PR2: Audit (Thin Logger)

### Changes
- [ ] Add audit types and schema
- [ ] Implement NEVER_LOG redaction
- [ ] Implement JSONL store with daily rotation
- [ ] Add AuditLogger service

### Tests
- [ ] NEVER_LOG enforcement tests (CRITICAL)
- [ ] JSONL store tests

### Verification
- [ ] NEVER_LOG test passes
- [ ] Can append and query audit entries
- [ ] `pnpm check` passes

### Guardrail
The NEVER_LOG test MUST pass. This blocks accidental content logging.
```

---

## What's Deferred to M3

- SecretDetector integration for errorMessage sanitization
- Hash chain integrity mode
- Alert engine
- Retention/cleanup by severity
- CLI commands (meao audit tail/search/export)

---

## Next Milestone

After completing M1.5, proceed to [M2: Security Primitives](./M2-security.md).

---

*Last updated: 2026-01-29*
